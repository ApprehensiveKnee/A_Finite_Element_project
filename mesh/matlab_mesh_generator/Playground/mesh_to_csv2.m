%MODIFIED::
% With respect to the original version provided by Paola Gervasio, in this case
% ifro returns the edge on which we can find a spefic node, while the
% the d.c. are given directly inside the C++ code for which this script mesh is
% used...
% Input: xa= abscissa of either vertex V1 or vertex V4
%        xb= abscissa of either vertex V2 or vertex V3
%        ya= ordinate of either vertex V1 or vertex V2
%        yb= ordinate of either vertex V3 or vertex V4
%        cb= a string of four elements, each for any side of \partial\Omega.
%          cb(i) refers to side number "i" of \partial\Omega
%          'd' character stands for Dirichlet boundary conditions on that side
%          'n' character stands for Neumann boundary conditions on that side
%        nex = number of elements along x-direction
%        ney = number of elements along y-direction
%        npdx = number of nodes in each element (the same in every element)
%               along x-direction
%        npdy = number of nodes in each element (the same in every element)
%               along y-direction
%        nov = local -global map, previously generated by cosnov_2d
%        x = npdx LGL nodes in [-1,1], previously generated by xwlgl
%        wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
%        y = npdy LGL nodes in [-1,1], previously generated by xwlgl
%        wy = npdy LGL weigths in [-1,1], previously generated by xwlgl
%        gammax = column or row array of length nex-1. 
%               If the deomposition of Omega is not
%               uniform, gammax is the vector of position of interfaces between
%               spectral elements along x-direction. If gammax=[], uniform
%               decomposition is used.
%        gammay = column or row array of length ney-1. 
%               If the deomposition of Omega is not
%               uniform, gammay is the vector of position of interfaces between
%               spectral elements along x-direction. If gammay=[], uniform
%               decomposition is used.
%
%
% Output: xx = 2-indexes array of size (4,ne) 
%            xx(1:4,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%         yy = 2-indexes array of size (4,ne):
%            yy(1:4,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie]
%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%         xy = column array with global mesh, length: noe=nov(npdx*npdy,ne)
%         ww = column array with global weigths, length: noe=nov(npdx*npdy,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%         ifro = 0 if node is internal
%                1 if node is on edge 1
%                2 if node is on edge 2
%                3 if node is on edge 3
%                4 if node is on edge 4
%                31-1 if node is on vertex 1
%                31-2 if node is on vertex 2
%                31-3 if node is on vertex 3
%                31-4 if node is on vertex 4



clear all;
close all;
clc; 


xa = 0;
xb = 1;
ya = 0;
yb = 1;
cb = strings(4,1);
cb(1)= 'd';cb(2)= 'd' ;cb(3)= 'd' ; cb(4)= 'd'; 
nex = 10;
ney = 10;
npdx = 2;
npdy = 2;
%as to why the number of nodes per element along a specific dimension has
%to be 2, read the mesh_to_csv1 file
nov =cosnov_2d(npdx,nex,npdy,ney);
[x,wx]=xwlgl(npdx);
[y,wy]=xwlgl(npdy);
gammax=[];
gammay=[];

[xx,yy,jacx,jacy,xy,ww,ifro]=mesh_2d(xa,xb,ya,yb,cb,nex,ney,npdx,npdy,nov,x,wx,y,wy,gammax,gammay);







