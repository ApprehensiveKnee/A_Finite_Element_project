
% Input: xa= abscissa of either vertex V1 or vertex V4
%        xb= abscissa of either vertex V2 or vertex V3
%        ya= ordinate of either vertex V1 or vertex V2
%        yb= ordinate of either vertex V3 or vertex V4
%        cb= a string of four elements, each for any side of \partial\Omega.
%          cb(i) refers to side number "i" of \partial\Omega
%          'd' character stands for Dirichlet boundary conditions on that side
%          'n' character stands for Neumann boundary conditions on that side
%        nex = number of elements along x-direction
%        ney = number of elements along y-direction
%        npdx = number of nodes in each element (the same in every element)
%               along x-direction
%        npdy = number of nodes in each element (the same in every element)
%               along y-direction
%        nov = local -global map, previously generated by cosnov_2d
%        x = npdx LGL nodes in [-1,1], previously generated by xwlgl
%        wx = npdx LGL weigths in [-1,1], previously generated by xwlgl
%        y = npdy LGL nodes in [-1,1], previously generated by xwlgl
%        wy = npdy LGL weigths in [-1,1], previously generated by xwlgl
%        gammax = column or row array of length nex-1. 
%               If the deomposition of Omega is not
%               uniform, gammax is the vector of position of interfaces between
%               spectral elements along x-direction. If gammax=[], uniform
%               decomposition is used.
%        gammay = column or row array of length ney-1. 
%               If the deomposition of Omega is not
%               uniform, gammay is the vector of position of interfaces between
%               spectral elements along x-direction. If gammay=[], uniform
%               decomposition is used.
%
%
% Output: xx = 2-indexes array of size (4,ne) 
%            xx(1:4,ie)=[x_V1_ie;x_V2_ie;x_V3_ie;x_V4_ie]
%            (ne=nex*ney is the global number of spectral elements)
%         yy = 2-indexes array of size (4,ne):
%            yy(1:4,ie)=[y_V1_ie;y_V2_ie;y_V3_ie;y_V4_ie]
%         jacx = array (length(jacx)=ne); jacx(ie)= (x_V2_ie-x_V1_ie)/2
%         jacy = array (length(jacy)=ne); jacy(ie)= (y_V3_ie-y_V1_ie)/2
%         xy = column array with global mesh, length: noe=nov(npdx*npdy,ne)
%         ww = column array with global weigths, length: noe=nov(npdx*npdy,ne)
%              diag(ww) is the mass matrix associated to SEM discretization
%         ifro = column array of length noe=nov(npdx*npdy,ne): 
%            if (x_i,y_i) is internal to Omega then ifro(i)=0,
%            if (x_i,y_i) is on \partial\Omega and Dirichlet boundary
%            condition is imposed there, then ifro(i)=1,
%            if (x_i,y_i) is on \partial\Omega and Neumann boundary
%            condition is imposed there, then ifro(i)=31,

clear all;
close all;
clc;

xa = 0;
xb = 100;
ya = 0;
yb = 100;
cb = strings(4,1);
cb(1)= 'd';cb(2)= 'd' ;cb(3)= 'd' ; cb(4)= 'd'; 
nex = 12;
ney = 12;
npdx = 2;
npdy = 2;
%as to why the number of nodes per element along a specific dimension has
%to be 2, read the mesh_to_csv1 file
nov =cosnov_2d(npdx,nex,npdy,ney);
[x,wx]=xwlgl(npdx);
[y,wy]=xwlgl(npdy);
gammax=[];
gammay=[];

[xx,yy,jacx,jacy,xy,ww,ifro]=mesh_2d(xa,xb,ya,yb,cb,nex,ney,npdx,npdy,nov,x,wx,y,wy,gammax,gammay);

%once the matrixes are correclty constructed, we move onto the creation of the
%csv files



%write nodes_coordinates.csv (global mesh nodes and corresponding coordinates)
ne = nex*ney;
noe=nov(npdx*npdy,ne);

numbers = [noe, ne];
T = array2table(numbers);
T.Properties.VariableNames(1:2) = {'Number of total nodes','Number of total elements'};
writetable(T,'numbers.csv')


nodes = zeros(noe,4);
nodes(:,1)= (1:noe);
nodes(:,2:3) = xy;
nodes(:,4)=ifro;

T = array2table(nodes);
T.Properties.VariableNames(1:4) = {'node_id','node_coordinate_x', 'node_coordinate_y', 'boundary'};
writetable(T,'nodes_coordinates.csv')
%write elements_vertexes.csv (each vertex inside each element)
%for this purpose the original mesh_1d function as been sligthly modified

%elems = cell(ne + 1, 5);
%elems(1,:) = ["ElementID," "GlobalId_1," "GlobalId_2#," "#GlobalId_3#," "#GlobalId_4#"];
elems = zeros(ne, 5);
elems(:,1)=(1:ne);
elems(:,2:5) = nov';

T = array2table(nodes);
T.Properties.VariableNames(1:4) = {'ElementID','GlobalId_1', 'GlobalId_2', 'lobalId_3', 'GlobalId_4'};
writetable(T,'nodes_coordinates.csv')



